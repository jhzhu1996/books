# 1. 万里长征第一步（非常重要） —— 如何愉快的阅读本小册

# 2. 装作自己是个小白 —— 重新认识MySQL

标签： MySQL是怎样运行的

* * *

## MySQL的客户端／服务器架构

以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。比如狗哥用微信给猫爷发了一条消息的过程其实是这样的：

1.  消息被客户端包装了一下，添加了发送者和接受者信息，然后从狗哥的微信客户端传送给微信服务器；

2.  微信服务器从消息里获取到它的发送者和接收者，根据消息的接受者信息把这条消息送达到猫爷的微信客户端，猫爷的微信客户端里就显示出狗哥给他发了一条消息。

`MySQL`的使用过程跟这个是一样的，它的服务器程序直接和我们存储的数据打交道，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。和微信一样，`MySQL`的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。我们日常使用`MySQL`的情景一般是这样的：

1.  启动`MySQL`服务器程序。
2.  启动`MySQL`客户端程序并连接到服务器程序。
3.  在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。

我们知道计算机很牛逼，在一台计算机上可以同时运行多个程序，比如微信、QQ、音乐播放器、文本编辑器啥的，每一个运行着的程序也被称为一个`进程`。我们的`MySQL`服务器程序和客户端程序本质上都算是计算机上的一个`进程`，这个代表着`MySQL`服务器程序的进程也被称为`MySQL数据库实例`，简称`数据库实例`。

每个进程都有一个唯一的编号，称为`进程ID`，英文名叫`PID`，这个编号是在我们启动程序的时候由操作系统随机分配的，操作系统会保证在某一时刻同一台机器上的进程号不重复。比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号，如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动 QQ程序的时候分配的就可能是另一个编号。每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的`MySQL`服务器进程的默认名称为`mysqld`， 而我们常用的`MySQL`客户端进程的默认名称为`mysql`。

## MySQL的安装

不论我们通过下载源代码自行编译安装的方式还是直接使用官方提供的安装包进行安装之后，`MySQL`的服务器程序和客户端程序都会被安装到我们的机器上。不论使用上述两者的哪种安装方式，一定一定一定（重要的话说三遍）要记住你把`MySQL`安装到哪了，换句话说，一定要记住`MySQL`的安装目录。

> 小贴士： \`MySQL\`的大部分安装包都包含了服务器程序和客户端程序，不过在Linux下使用RPM包时会有单独的服务器RPM包和客户端RPM包，需要分别安装。

另外，`MySQL`可以运行在各种各样的操作系统上，我们后边会讨论在类`UNIX`操作系统和`Windows`操作系统上使用的一些差别。为了方便大家理解，我在`macOS` 操作系统（苹果电脑使用的操作系统）和`Windows`操作系统上都安装了`MySQL`，它们的安装目录分别是：

*   `macOS`操作系统上的安装目录：

```
/usr/local/mysql/
```

*   `Windows`操作系统上的安装目录：

```
C:\Program Files\MySQL\MySQL Server 5.7
```

下边我会以这两个安装目录为例来进一步扯出更多的概念，不过一定要注意，这两个安装目录是我的运行不同操作系统的机器上的安装目录，一定要记着把下边示例中用到安装目录的地方替换为你自己机器上的安装目录。

> 小贴士： 类UNIX操作系统非常多，比如FreeBSD、Linux、macOS、Solaris等都属于UNIX操作系统的范畴，我们这里使用macOS操作系统代表类UNIX操作系统来运行MySQL。

### bin目录下的可执行文件

在`MySQL`的安装目录下有一个特别特别重要的`bin`目录，这个目录下存放着许多可执行文件，以`macOS`系统为例，这个`bin`目录的绝对路径就是（在我的机器上）：

```
/usr/local/mysql/bin
```

我们列出一些在`macOS`中这个`bin`目录下的一部分可执行文件来看一下（文件太多，全列出来会刷屏的）：

```
.
├── mysql
├── mysql.server -> ../support-files/mysql.server
├── mysqladmin
├── mysqlbinlog
├── mysqlcheck
├── mysqld
├── mysqld_multi
├── mysqld_safe
├── mysqldump
├── mysqlimport
├── mysqlpump
... (省略其他文件)
0 directories, 40 files

```

`Windows`中的可执行文件与`macOS`中的类似，不过都是以`.exe`为扩展名的。这些可执行文件都是与服务器程序和客户端程序相关的，后边我们会详细唠叨一些比较重要的可执行文件，现在先看看执行这些文件的方式。

对于有可视化界面的操作系统来说，我们拿着鼠标点点点就可以执行某个可执行文件，不过现在我们更关注在命令行环境下如何执行这些可执行文件，命令行通俗的说就是那些黑框框，这里的指的是类`UNIX`系统中的`Shell`或者`Windows`系统中的`cmd.exe`，如果你现在还不知道怎么启动这些命令行工具，网上搜搜吧～ 下边我们以`macOS`系统为例来看看如何启动这些可执行文件（`Windows`中的操作是类似的，依葫芦画瓢就好了）

* 使用可执行文件的相对／绝对路径

  假设我们现在所处的工作目录是`MySQL`的安装目录，也就是`/usr/local/mysql`，我们想启动`bin`目录下的`mysqld`这个可执行文件，可以使用相对路径来启动：

  ```
  ./bin/mysqld
  ```
  

或者直接输入`mysqld`的绝对路径也可以：

```
  /usr/local/mysql/bin/mysqld
```

* 将该`bin`目录的路径加入到环境变量`PATH`中

  如果我们觉得每次执行一个文件都要输入一串长长的路径名贼麻烦的话，可以把该`bin`目录所在的路径添加到环境变量`PATH`中。环境变量`PATH`是一系列路径的集合，各个路径之间使用冒号`:`隔离开，比方说我的机器上的环境变量`PATH`的值就是：

  ```
  /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
  ```
  

我的系统中这个环境变量`PATH`的值表明：当我在输入一个命令时，系统便会在`/usr/local/bin`、`/usr/bin:`、`/bin:`、`/usr/sbin`、`/sbin`这些目录下依次寻找是否存在我们输入的那个命令，如果寻找成功，则执行该目录下对应的可执行文件。所以我们现在可以修改一下这个环境变量`PATH`，把`MySQL`安装目录下的`bin`目录的路径也加入到`PATH`中，在我的机器上修改后的环境变量`PATH`的值为：

```
  /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mysql/bin
```

  这样现在不论我们所处的工作目录是啥，我们都可以直接输入可执行文件的名字就可以启动它，比如这样：

  ```
mysqld
  ```

  方便多了哈～

> 小贴士： 关于啥是环境变量以及如何在当前系统中添加或修改系统变量不是我们唠叨的范围，大家找本相关的书或者上网查一查哈～

## 启动MySQL服务器程序

### UNIX里启动服务器程序

在类`UNIX`系统中用来启动`MySQL`服务器程序的可执行文件有很多，大多在`MySQL`安装目录的`bin`目录下，我们一起来瞅瞅。

#### mysqld

`mysqld`这个可执行文件就代表着`MySQL`服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但这个命令不常用，我们继续往下看更牛逼的启动命令。

#### mysqld\_safe

`mysqld_safe`是一个启动脚本，它会间接的调用`mysqld`，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用`mysqld_safe`启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。

#### mysql.server

`mysql.server`也是一个启动脚本，它会间接的调用`mysqld_safe`，在调用`mysql.server`时在后边指定`start`参数就可以启动服务器程序了，就像这样：

```
mysql.server start
```

需要注意的是，这个 _**mysql.server**_ 文件其实是一个链接文件，它的实际文件是 _**../support-files/mysql.server**_。我使用的`macOS`操作系统会帮我们在`bin`目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有帮你自动创建这个链接文件，那就自己创建一个呗～ 别告诉我你不会创建链接文件，上网搜搜呗～

另外，我们还可以使用`mysql.server`命令来关闭正在运行的服务器程序，只要把`start`参数换成`stop`就好了：

```
mysql.server stop
```

#### mysqld\_multi

其实我们一台计算机上也可以运行多个服务器实例，也就是运行多个`MySQL`服务器进程。`mysql_multi`可执行文件可以对每一个服务器进程的启动或停止进行监控。这个命令的使用比较复杂，本书主要是为了讲清楚`MySQL`服务器和客户端运行的过程，不会对启动多个服务器程序进行过多唠叨。

### Windows里启动服务器程序

`Windows`里没有像类`UNIX`系统中那么多的启动脚本，但是也提供了手动启动和以服务的形式启动这两种方式，下边我们详细看。

#### mysqld

同样的，在`MySQL`安装目录下的`bin`目录下有一个`mysqld`可执行文件，在命令行里输入`mysqld`，或者直接双击运行它就算启动了`MySQL`服务器程序了。

#### 以服务的方式运行服务器程序

首先看看啥是个`Windows` 服务？如果无论是谁正在使用这台计算机，我们都需要长时间的运行某个程序，而且需要在计算机启动的时候便启动它，一般我们都会把它注册为一个`Windows 服务`，操作系统会帮我们管理它。把某个程序注册为`Windows`服务的方式挺简单，如下：

```
"完整的可执行文件路径" --install [-manual] [服务名]
```

其中的`-manual`可以省略，加上它的话表示在`Windows`系统启动的时候不自动启动该服务，否则会自动启动。`服务名`也可以省略，默认的服务名就是`MySQL`。比如我的`Windows`计算机上`mysqld`的完整路径是：

```
C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld
```

所以如果我们想把它注册为服务的话可以在命令行里这么写：

```
"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --install
```

在把`mysqld`注册为`Windows`服务之后，我们就可以通过下边这个命令来启动`MySQL`服务器程序了：

```
net start MySQL
```

当然，如果你喜欢图形界面的话，你可以通过`Windows`的服务管理器通过用鼠标点点点的方式来启动和停止服务（作为一个程序猿，还是用黑框框吧～）。

关闭这个服务也非常简单，只要把上边的`start`换成`stop`就行了，就像这样：

```
net stop MySQL
```

## 启动MySQL客户端程序

在我们成功启动`MySQL`服务器程序后，就可以接着启动客户端程序来连接到这个服务器喽，`bin`目录下有许多客户端程序，比方说`mysqladmin`、`mysqldump`、`mysqlcheck`等等等等（好多呢，就不一一列举了）。这里我们重点要关注的是可执行文件`mysql`，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接受服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下：

```
mysql -h主机名  -u用户名 -p密码
```

各个参数的意义如下：

参数名

含义

`-h`

表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填`localhost`或者`127.0.0.1`。也可以写作 `--host=主机名`的形式。

`-u`

表示用户名。也可以写作 `--user=用户名`的形式。

`-p`

表示密码。也可以写作 `--password=密码`的形式。

> 小贴士： 像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前边需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前边需要加双短划线。后边会详细讨论这些参数的使用方式的，稍安勿躁～

比如我这样执行下边这个可执行文件(用户名密码按你的实际情况填写)，就可以启动`MySQL`客户端，并且连接到服务器了。

```
mysql -hlocalhost -uroot -p123456
```

我们看一下连接成功后的界面：

```
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.21 Homebrew

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> 

```

最后一行的`mysql>`是一个客户端的提示符，之后客户端发送给服务器的命令都需要写在这个提示符后边。

如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在`mysql>`提示符后输入下边任意一个命令：

1.  `quit`
2.  `exit`
3.  `\q`

比如我们输入`quit`试试：

```
mysql> quit
Bye

```

输出了`Bye`说明客户端程序已经关掉了。注意注意注意，这是关闭客户端程序的方式，不是关闭服务器程序的方式，怎么关闭服务器程序上一节里唠叨过了。

如果你愿意，你可以多打开几个黑框框，每个黑框框都使用`mysql -hlocahhost -uroot -p123456`来运行多个客户端程序，每个客户端程序都是互不影响的。如果你有多个电脑，也可以试试把它们用局域网连起来，在一个电脑上启动`MySQL`服务器程序，在另一个电脑上执行`mysql`命令时使用`IP`地址作为主机名来连接到服务器。

### 连接注意事项

* 最好不要在一行命令中输入密码。

  我们直接在黑框框里输入密码很可能被别人看到，这和你当着别人的面输入银行卡密码没啥区别，所以我们在执行`mysql`连接服务器的时候可以不显式的写出密码，就像这样：

  ```
  mysql -hlocahhost -uroot -p
  ```
  

点击回车之后才会提示你输入密码：

```
  Enter password:
```

  不过这回你输入的密码不会被显示出来，心怀不轨的人也就看不到了，输入完成点击回车就成功连接到了服务器。

* 如果你非要在一行命令中显式的把密码输出来，那`-p`和密码值之间不能有空白字符（其他参数名之间可以有空白字符），就像这样：

  ```
  mysql -h localhost -u root -p123456
  ```
  

如果加上了空白字符就是错误的，比如这样：

```
  mysql -h localhost -u root -p 123456
```

* `mysql`的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：

  ```
  mysql -p  -u root -h localhost
  ```
  
* 如果你的服务器和客户端安装在同一台机器上，`-h`参数可以省略，就像这样：

  ```
  mysql -u root -p  
  ```
  
* 如果你使用的是类`UNIX`系统，并且省略`-u`参数后，会把你登陆操作系统的用户名当作`MySQL`的用户名去处理。

  比方说我用登录操作系统的用户名是`xiaohaizi`，那么在我的机器上下边这两条命令是等价的：

  ```
  mysql -u xiaohaizi -p
  mysql -p
  ```
  

对于`Windows`系统来说，默认的用户名是`ODBC`，你可以通过设置环境变量`USER`来添加一个默认用户名。

## 客户端与服务器连接的过程

我们现在已经知道如何启动`MySQL`的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！`MySQL`支持下边三种客户端进程和服务器进程的通信方式。

### TCP/IP

真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。`MySQL`采用`TCP`作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的`IP地址`，如果某个进程有需要采用`TCP`协议进行网络通信方面的需求，可以向操作系统申请一个`端口号`，这是一个整数值，它的取值范围是`0~65535`。这样在网络中的其他进程就可以通过`IP地址 + 端口号`的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。

`MySQL`服务器启动的时候会默认申请`3306`端口号，之后就在这个端口号上等待客户端进程进行连接，用书面一点的话来说，`MySQL`服务器会默认监听`3306`端口。

> 小贴士： \`TCP/IP\`网络体系结构是现在通用的一种网络体系结构，其中的\`TCP\`和\`IP\`是体系结构中两个非常重要的网络协议，如果你并不知道协议是什么，或者并不知道网络是什么，那恐怕兄弟你来错地方了，找本计算机网络的书去瞅瞅吧！ 什么？计算机网络的书写的都贼恶心，看不懂？没关系，等我～

如果`3306`端口号已经被别的进程占用了或者我们单纯的想自定义该数据库实例监听的端口号，那我们可以在启动服务器程序的命令行里添加`-P`参数来明确指定一下端口号，比如这样：

```
mysqld -P3307

```

这样`MySQL`服务器在启动时就会去监听我们指定的端口号`3307`。

如果客户端进程想要使用`TCP/IP`网络来连接到服务器进程，比如我们在使用`mysql`来启动客户端程序时，在`-h`参数后必须跟随`IP地址`来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用`127.0.0.1`来代表本机的`IP地址`。另外，如果服务器进程监听的端口号不是默认的`3306`，我们也可以在使用`mysql`启动客户端程序时使用`-P`参数（大写的`P`，小写的`p`是用来指定密码的）来指定需要连接到的端口号。比如我们现在已经在本机启动了服务器进程，监听的端口号为`3307`，那我们启动客户端程序时可以这样写：

```
mysql -h127.0.0.1 -uroot -P3307 -p

```

不知大家发现了没有，我们在启动服务器程序的命令`mysqld`和启动客户端程序的命令`mysql`后边都可以使用`-P`参数，关于如何在命令后边指定参数，指定哪些参数我们稍后会详细唠叨的，稍微等等哈～

### 命名管道和共享内存

如果你是一个`Windows`用户，那么客户端进程和服务器进程之间可以考虑使用`命名管道`或`共享内存`进行通信。不过启用这些通信方式的时候需要在启动服务器程序和客户端程序时添加一些参数：

* 使用`命名管道`来进行进程间通信

  需要在启动服务器程序的命令中加上`--enable-named-pipe`参数，然后在启动客户端程序的命令中加入`--pipe`或者`--protocol=pipe`参数。

* 使用`共享内存`来进行进程间通信

  需要在启动服务器程序的命令中加上`--shared-memory`参数，在成功启动服务器后，`共享内存`便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入`--protocol=memory`参数来显式的指定使用共享内存进行通信。

  不过需要注意的是，使用`共享内存`的方式进行通信的服务器进程和客户端进程必须在同一台`Windows`主机中。

> 小贴士： 命名管道和共享内存是Windows操作系统中的两种进程间通信方式，如果你没听过的话也不用纠结，并不妨碍我们介绍MySQL的知识～

### Unix域套接字文件

如果我们的服务器进程和客户端进程都运行在同一台操作系统为类`Unix`的机器上的话，我们可以使用`Unix域套接字文件`来进行进程间通信。如果我们在启动客户端程序的时候指定的主机名为`localhost`，或者指定了`--protocal=socket`的启动参数，那服务器程序和客户端程序之间就可以通过`Unix`域套接字文件来进行通信了。`MySQL`服务器程序默认监听的`Unix`域套接字文件路径为`/tmp/mysql.sock`，客户端程序也默认连接到这个`Unix`域套接字文件。如果我们想改变这个默认路径，可以在启动服务器程序时指定`socket`参数，就像这样：

```
mysqld --socket=/tmp/a.txt

```

这样服务器启动后便会监听`/tmp/a.txt`。在服务器改变了默认的`UNIX`域套接字文件后，如果客户端程序想通过`UNIX`域套接字文件进行通信的话，也需要显式的指定连接到的`UNIX`域套接字文件路径，就像这样：

```
mysql -hlocalhost -uroot --socket=/tmp/a.txt -p

```

这样该客户端进程和服务器进程就可以通过路径为`/tmp/a.txt`的`Unix`域套接字文件进行通信了。

## 服务器处理客户端请求

其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：

![image_1c8d26fmg1af0ms81cpc7gm8lv39.png-97.9kB](https://user-gold-cdn.xitu.io/2018/12/28/167f4c7b99f87e1c?w=842&h=559&f=png&s=100231)

从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是`连接管理`、`解析与优化`、`存储引擎`。下边我们来详细看一下这三个部分都干了什么。

### 连接管理

客户端进程可以采用我们上边介绍的`TCP/IP`、`命名管道或共享内存`、`Unix域套接字`这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。从这一点大家也能看出，`MySQL`服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说哈～

在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了`SSL`（安全套接字）的网络连接进行通信，来保证数据传输的安全性。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，`MySQL`服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看哈～

### 解析与优化

到现在为止，`MySQL`服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是`查询缓存`、`语法解析`和`查询优化`，下边我们详细来看。

#### 查询缓存

如果我问你`9+8×16-3×2×17`的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果`35`，如果我再问你一遍`9+8×16-3×2×17`的值是多少，你还用再傻呵呵的算一遍么？我们刚刚已经算过了，直接说答案就好了。`MySQL`服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果`缓存`起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。

当然，`MySQL`服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information\_schema、 performance\_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数`NOW`，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！

不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、 `UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或 `DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！

> 小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

#### 语法解析

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。

> 小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。

#### 查询优化

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用`EXPLAIN`语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在`MySQL`服务器程序处理请求的过程中有这么一个步骤就好了。

### 存储引擎

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里。我们知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。为了实现不同的功能，`MySQL`提供了各式各样的`存储引擎`，不同`存储引擎`管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

> 小贴士： 为什么叫\`引擎\`呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做\`表处理器\`，后来可能人们觉得太土，就改成了\`存储引擎\`的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。

为了管理方便，人们把`连接管理`、`查询缓存`、`语法解析`、`查询优化`这些并不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为`存储引擎`的功能。各种不同的存储引擎向上边的`MySQL server`层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

所以在`MySQL server`完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

## 常用存储引擎

`MySQL`支持非常多种存储引擎，我这先列举一些：

存储引擎

描述

`ARCHIVE`

用于数据存档（行被插入后不能再修改）

`BLACKHOLE`

丢弃写操作，读操作会返回空内容

`CSV`

在存储数据时，以逗号分隔各个数据项

`FEDERATED`

用来访问远程表

`InnoDB`

具备外键支持功能的事务存储引擎

`MEMORY`

置于内存的表

`MERGE`

用来管理多个MyISAM表构成的表集合

`MyISAM`

主要的非事务处理存储引擎

`NDB`

MySQL集群专用存储引擎

这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是`InnoDB`和`MyISAM`，有时会提一下`Memory`。其中`InnoDB`是`MySQL`默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：

Feature

MyISAM

Memory

InnoDB

Archive

NDB

B-tree indexes

yes

yes

yes

no

no

Backup/point-in-time recovery

yes

yes

yes

yes

yes

Cluster database support

no

no

no

no

yes

Clustered indexes

no

no

yes

no

no

Compressed data

yes

no

yes

yes

no

Data caches

no

N/A

yes

no

yes

Encrypted data

yes

yes

yes

yes

yes

Foreign key support

no

no

yes

no

yes

Full-text search indexes

yes

no

yes

no

no

Geospatial data type support

yes

no

yes

yes

yes

Geospatial indexing support

yes

no

yes

no

no

Hash indexes

no

yes

no

no

yes

Index caches

yes

N/A

yes

no

yes

Locking granularity

Table

Table

Row

Row

Row

MVCC

no

no

yes

no

no

Query cache support

yes

yes

yes

yes

yes

Replication support

yes

Limited

yes

yes

yes

Storage limits

256TB

RAM

64TB

None

384EB

T-tree indexes

no

no

no

no

yes

Transactions

no

no

yes

no

yes

Update statistics for data dictionary

yes

yes

yes

yes

yes

密密麻麻列了这么多，看的头皮都发麻了，达到的效果就是告诉你：这玩意儿很复杂。其实这些东西大家没必要立即就给记住，我列出来的目的就是想让大家明白不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的唠叨中慢慢让大家理解的～

## 关于存储引擎的一些操作

### 查看当前服务器程序支持的存储引擎

我们可以用下边这个命令来查看当前服务器程序支持的存储引擎：

```
SHOW ENGINES;

```

来看一下调用效果：

```
mysql> SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)

mysql>

```

其中的`Support`列表示该存储引擎是否可用，`DEFAULT`值代表是当前服务器程序的默认存储引擎。`Comment`列是对存储引擎的一个描述，英文的，将就着看吧。`Transactions`列代表该存储引擎是否支持事务处理。`XA`列代表着该存储引擎是否支持分布式事务。`Savepoints`代表着该列是否支持部分事务回滚。

> 小贴士： 好吧，也许你并不知道什么是个事务、更别提分布式事务了，这些内容我们在后边的章节会详细唠叨，现在瞅一眼看个新鲜就得了。

### 设置表的存储引擎

我们前边说过，存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

#### 创建表时指定存储引擎

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎`InnoDB`（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：

```
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;

```

比如我们想创建一个存储引擎为`MyISAM`的表可以这么写：

```
mysql> CREATE TABLE engine_demo_table(
    ->     i int
    -> ) ENGINE = MyISAM;
Query OK, 0 rows affected (0.02 sec)

mysql>

```

#### 修改表的存储引擎

如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：

```
ALTER TABLE 表名 ENGINE = 存储引擎名称;

```

比如我们修改一下`engine_demo_table`表的存储引擎：

```
mysql> ALTER TABLE engine_demo_table ENGINE = InnoDB;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql>

```

这时我们再查看一下`engine_demo_table`的表结构：

```
mysql> SHOW CREATE TABLE engine_demo_table\G
*************************** 1. row ***************************
       Table: engine_demo_table
Create Table: CREATE TABLE `engine_demo_table` (
  `i` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.01 sec)

mysql>

```

可以看到该表的存储引擎已经改为`InnoDB`了。

# 3. MySQL的调控按钮 —— 启动选项和系统变量

# 4. 乱码的前世今生 —— 字符集和比较规则

# 5. 从一条记录说起—— InnoDB 记录结构

标签： MySQL 是怎样运行的

* * *

## 准备工作

到现在为止，`MySQL`对于我们来说还是一个黑盒，我们只负责使用客户端发送请求并等待服务器返回结果，表中的数据到底存到了哪里？以什么格式存放的？`MySQL`是以什么方式来访问的这些数据？这些问题我们统统不知道，对于未知领域的探索向来就是社会主义核心价值观中的一部分，作为新一代社会主义接班人，不把它们搞懂怎么支援祖国建设呢？

我们前边唠叨请求处理过程的时候提到过，`MySQL`服务器上负责对表中数据的读取和写入工作的部分是`存储引擎`，而服务器又支持不同类型的存储引擎，比如`InnoDB`、`MyISAM`、`Memory`啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如`Memory`都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于`InnoDB`是`MySQL`默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用`InnoDB`作为存储引擎的数据存储结构，了解了一个存储引擎的数据存储结构之后，其他的存储引擎都是依葫芦画瓢，等我们用到了再说哈～

## InnoDB页简介

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，`InnoDB`存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，`InnoDB`采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 _**16**_ KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## InnoDB行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。设计`InnoDB`存储引擎的大叔们到现在为止设计了4种不同类型的`行格式`，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

### 指定行格式的语法

我们可以在创建或修改表的语句中指定`行格式`：

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称

```

比如我们在`xiaohaizi`数据库里创建一个演示用的表`record_format_demo`，可以这样指定它的`行格式`：

```
mysql> USE xiaohaizi;
Database changed

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)

```

可以看到我们刚刚创建的这个表的`行格式`就是`Compact`，另外，我们还显式指定了这个表的字符集为`ascii`，因为`ascii`字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这个表里的。我们现在向这个表中插入两条记录：

```
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0

```

现在表中的记录就是这个样子的：

```
mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)

mysql>

```

演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～

### COMPACT行格式

废话不多说，直接看图：

![image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5702043d7?w=783&h=250&f=png&s=43461)

大家从图中可以看出来，一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分，下边我们详细看一下这两部分的组成。

#### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`，我们分别看一下。

##### 变长字段长度列表

我们知道`MySQL`支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，我们也可以把拥有这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1.  真正的数据内容
2.  占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！

我们拿`record_format_demo`表中的第一条记录来举个例子。因为`record_format_demo`表的`c1`、`c2`、`c4`列都是`VARCHAR(10)`类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为`record_format_demo`表中的各个列都使用的是`ascii`字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

| 列名 | 存储内容 | 内容长度（十进制表示） | 内容长度（十六进制表示） |
| ---- | -------- | ---------------------- | ------------------------ |
| `c1` | `'aaaa'` | `4`                    | `0x04`                   |
| `c2` | `'bbb'`  | `3`                    | `0x03`                   |
| `c4` | `'d'`    | `1`                    | `0x01`                   |

又因为这些长度值需要按照列的逆序存放，所以最后`变长字段长度列表`的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：

```
01 03 04 
```

把这个字节串组成的`变长字段长度列表`填入上边的示意图中的效果就是：

![image_1c9gbruvo504dlg1qsf19nbeu878.png-37kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f570f8ed73?w=1004&h=192&f=png&s=37847)

由于第一行记录中`c1`、`c2`、`c4`列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，`InnoDB`有它的一套规则，我们首先声明一下`W`、`M`和`L`的意思：

1.  假设某个字符集中表示一个字符最多需要使用的字节数为`W`，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`字符集中的`W`就是`3`，`gbk`字符集中的`W`就是`2`，`ascii`字符集中的`W`就是`1`。

2.  对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是`M×W`。

3.  假设它实际存储的字符串占用的字节数是`L`。

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

* 如果`M×W <= 255`，那么使用1个字节来表示真正字符串占用的字节数。

  > 也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。

* 如果`M×W > 255`，则分为两种情况：

  *   如果`L <= 127`，则用1个字节来表示真正字符串占用的字节数。

  *   如果`L > 127`，则用2个字节来表示真正字符串占用的字节数。

  > InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。 对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

总结一下就是说：如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节。

另外需要注意的一点是，变长字段长度列表中只存储值为 _**非NULL**_ 的列内容占用的长度，值为 _**NULL**_ 的列的长度是不储存的 。也就是说对于第二条记录来说，因为`c4`列的值为`NULL`，所以第二条记录的`变长字段长度列表`只需要存储`c1`和`c2`列的长度即可。其中`c1`列存储的值为`'eeee'`，占用的字节数为`4`，`c2`列存储的值为`'fff'`，占用的字节数为`3`，所以`变长字段长度列表`需2个字节。填充完`变长字段长度列表`的两条记录的对比图如下：

![image_1c9grq2b2jok1062t8tov21lqjbj.png-42.6kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5719c4037?w=742&h=239&f=png&s=43624)

> 小贴士： 并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

##### NULL值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1. 首先统计表中允许存储`NULL`的列有哪些。

   我们前边说过，主键列、被`NOT NULL`修饰的列都是不可以存储`NULL`值的，所以在统计的时候不会把这些列算进去。比方说表`record_format_demo`的3个列`c1`、`c3`、`c4`都是允许存储`NULL`值的，而`c2`列是被`NOT NULL`修饰，不允许存储`NULL`值。

2. 如果表中没有允许存储 _**NULL**_ 的列，则 _NULL值列表_ 也不存在了，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：

   *   二进制位的值为`1`时，代表该列的值为`NULL`。
   *   二进制位的值为`0`时，代表该列的值不为`NULL`。

   因为表`record_format_demo`有3个值允许为`NULL`的列，所以这3个列和二进制位的对应关系就是这样：

   ![image_1c9g88mtt1tj51ua1qh51vjo12pg5k.png-10.4kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5728fdd01)

   再一次强调，二进制位按照列的顺序逆序排列，所以第一个列`c1`和最后一个二进制位对应。

3. `MySQL`规定`NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。

   表`record_format_demo`只有3个值允许为`NULL`的列，对应3个二进制位，不足一个字节，所以在字节的高位补`0`，效果就是这样：

   ![image_1c9g8g27b1bdlu7t187emsc46s61.png-19.4kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f574d5df2e?w=374&h=301&f=png&s=19883)

   以此类推，如果一个表中有9个允许为`NULL`，那这个记录的`NULL`值列表部分就需要2个字节来表示了。

知道了规则之后，我们再返回头看表`record_format_demo`中的两条记录中的`NULL值列表`应该怎么储存。因为只有`c1`、`c3`、`c4`这3个列允许存储`NULL`值，所以所有记录的`NULL值列表`只需要一个字节。

* 对于第一条记录来说，`c1`、`c3`、`c4`这3个列的值都不为`NULL`，所以它们对应的二进制位都是`0`，画个图就是这样：

  ![image_1c9g8m05b19ge1c8v2bf163djre6e.png-21.5kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5756f3663?w=346&h=308&f=png&s=22040)

  所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。

* 对于第二条记录来说，`c1`、`c3`、`c4`这3个列中`c3`和`c4`的值都为`NULL`，所以这3个列对应的二进制位的情况就是：

  ![image_1c9g8ps5c1snv1bhj3m48151sfl6r.png-20.6kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5a46c082d?w=332&h=316&f=png&s=21067)

  所以第二条记录的`NULL值列表`用十六进制表示就是：`0x06`。

所以这两条记录在填充了`NULL值列表`后的示意图就是这样：

![image_1c9grs9m4co8134u1t2rjhm1q6rc0.png-39kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5a7c50032?w=729&h=233&f=png&s=39932)

##### 记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![image_1c9geiglj1ah31meo80ci8n1eli8f.png-29.5kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5a87e0271?w=1174&h=244&f=png&s=30222)

这些二进制位代表的详细信息如下表：

| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| `预留位1`      | `1`               | 没有使用                                                     |
| `预留位2`      | `1`               | 没有使用                                                     |
| `delete_mask`  | `1`               | 标记该记录是否被删除                                         |
| `min_rec_mask` | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | `4`               | 表示当前记录拥有的记录数                                     |
| `heap_no`      | `13`              | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | `3`               | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | `16`              | 表示下一条记录的相对位置                                     |

大家不要被这么多的属性和陌生的概念给吓着，我这里只是为了内容的完整性把这些位代表的意思都写了出来，现在没必要把它们的意思都记住，记住也没啥用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候我们再回过头来看。

因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。所以我们现在直接看一下`record_format_demo`中的两条记录的`头信息`分别是什么：

![image_1c9gruej1am71ph9refjli16lhct.png-149.8kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5a964cbf3?w=1078&h=525&f=png&s=153365)

> 小贴士： 再一次强调，大家如果看不懂记录头信息里各个位代表的概念千万别纠结，我们后边会说的～

#### 记录的真实数据

对于`record_format_demo`表来说，`记录的真实数据`除了`c1`、`c2`、`c3`、`c4`这几个我们自己定义的列的数据以外，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | `6`字节  | 事务ID                 |
| `roll_pointer`   | 是       | `7`字节  | 回滚指针               |

> 小贴士： 实际上这几个列的真正名称其实是：DB\_ROW\_ID、DB\_TRX\_ID、DB\_ROLL\_PTR，我们为了美观才写成了row\_id、transaction\_id和roll\_pointer。

这里需要提一下`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 _**transaction\_id**_ 和 _**roll\_pointer**_ 这两个列，但是 _**row\_id**_ 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

因为表`record_format_demo`并没有定义主键，所以`MySQL`服务器会为每条记录增加上述的3个列。现在看一下加上`记录的真实数据`的两个记录长什么样吧：

![image_1c9h256f9nke14311adhtu61ie2dn.png-92kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5aa08037c?w=1094&h=354&f=png&s=94249)

看这个图的时候我们需要注意几点：

1.  表`record_format_demo`使用的是`ascii`字符集，所以`0x61616161`就表示字符串`'aaaa'`，`0x626262`就表示字符串`'bbb'`，以此类推。

2.  注意第1条记录中`c3`列的值，它是`CHAR(10)`类型的，它实际存储的字符串是：`'cc'`，而`ascii`字符集中的字节表示是`'0x6363'`，虽然表示这个字符串只占用了2个字节，但整个`c3`列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在`ascii`字符集的表示就是`0x20`。

3.  注意第2条记录中`c3`和`c4`列的值都为`NULL`，它们被存储在了前边的`NULL值列表`处，在记录的真实数据处就不再冗余存储，从而节省存储空间。

#### CHAR(M)列的存储格式

`record_format_demo`表的`c1`、`c2`、`c4`列的类型是`VARCHAR(10)`，而`c3`列的类型是`CHAR(10)`，我们说在`Compact`行格式下只会把变长类型的列的长度逆序存到`变长字段长度列表`中，就像这样：

![image_1c9jdkga71kegkjs14o111ov1ce3kn.png-12.5kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5cfa6ef3d?w=322&h=152&f=png&s=12767)

但是这只是因为我们的`record_format_demo`表采用的是`ascii`字符集，这个字符集是一个定长字符集，也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如`gbk`表示一个字符要1\~2个字节、`utf8`表示一个字符要1\~3个字节等）的话，`c3`列的长度也会被存储到`变长字段长度列表`中，比如我们修改一下`record_format_demo`表的字符集：

```
mysql> ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0

```

修改该列字符集后记录的`变长字段长度列表`也发生了变化，如图：

![image_1c9jeb6defgf1o981lgfciokjl4.png-43.1kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5d047e541?w=545&h=459&f=png&s=44156)

这就意味着：对于 _**CHAR(M)**_ 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

另外有一点还需要注意，变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间称为所谓的碎片。（这里你感受到设计`Compact`行格式的大叔既想节省存储空间，又不想更新`CHAR(M)`类型的列产生碎片时的纠结心情了吧。）

### Redundant行格式

其实知道了`Compact`行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的`Redundant`行格式是`MySQL5.0`之前用的一种行格式，也就是说它已经非常老了，但是本着知识完整性的角度还是要提一下，大家乐呵乐呵的看就好。

画个图展示一下`Redundant`行格式的全貌：

![image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5d1399d5f?w=618&h=251&f=png&s=37063)

现在我们把表`record_format_demo`的行格式修改为`Redundant`：

```
mysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

```

为了方便大家理解和节省篇幅，我们直接把表`record_format_demo`在`Redundant`行格式下的两条记录的真实存储数据提供出来，之后我们着重分析两种行格式的不同即可。

![image_1c9h8tnav166c187m1nhap61153qgn.png-91.6kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5d357a6e0?w=1046&h=337&f=png&s=93778)

下边我们从各个方面看一下`Redundant`行格式有什么不同的地方：

* 字段长度偏移列表

  注意`Compact`行格式的开头是`变长字段长度列表`，而`Redundant`行格式的开头是`字段长度偏移列表`，与`变长字段长度列表`有两处不同：

  * 没有了变长两个字，意味着`Redundant`行格式会把该条记录中所有列（包括`隐藏列`）的长度信息都按照逆序存储到`字段长度偏移列表`。

  * 多了个偏移两个字，这意味着计算列值长度的方式不像`Compact`行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。

    比如第一条记录的`字段长度偏移列表`就是：

    ```
    25 24 1A 17 13 0C 06
    
    ```

    因为它是逆序排放的，所以按照列的顺序排列就是：

    ```
    06 0C 13 17 1A 24 25
    
    ```

    按照两个相邻数值的差值来计算各个列值的长度的意思就是：

    ```
    第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。
    
    第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。
    
    第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。
    
    第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。
    
    第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。
    
    第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。
    
    第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。
    
    ```

* 记录头信息

  `Redundant`行格式的记录头信息占用`6`字节，`48`个二进制位，这些二进制位代表的意思如下：

  | 名称              | 大小（单位：bit） | 描述                                                     |
| ----------------- | ----------------- | -------------------------------------------------------- |
  | `预留位1`         | `1`               | 没有使用                                                 |
| `预留位2`         | `1`               | 没有使用                                                 |
  | `delete_mask`     | `1`               | 标记该记录是否被删除                                     |
| `min_rec_mask`    | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记           |
  | `n_owned`         | `4`               | 表示当前记录拥有的记录数                                 |
| `heap_no`         | `13`              | 表示当前记录在页面堆的位置信息                           |
  | `n_field`         | `10`              | 表示记录中列的数量                                       |
| `1byte_offs_flag` | `1`               | 标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的 |
  | `next_record`     | `16`              | 表示下一条记录的相对位置                                 |

  第一条记录中的头信息是：

  ```
00 00 10 0F 00 BC
  
```
  
根据这六个字节可以计算出各个属性的值，如下：
  
```
  预留位1：0x00
预留位2：0x00
  delete_mask: 0x00
min_rec_mask: 0x00
  n_owned: 0x00
heap_no: 0x02
  n_field: 0x07
1byte_offs_flag: 0x01
  next_record:0xBC

  ```

  与`Compact`行格式的记录头信息对比来看，有两处不同：

  *   `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。

  *   `Redundant`行格式没有`record_type`这个属性。

* `Redundant`行格式中`NULL`值的处理

  因为`Redundant`行格式并没有`NULL值列表`，所以需要别的方式来存储字段的`NULL`值，具体策略如下：

  * 如果该存储`NULL`值的字段是变长数据类型的，则在字段长度偏移列表中记录即可，并不占用记录的真实数据部分。

    比如`record_format_demo`表的`c4`列是`VARCHAR(10)`类型的，而第二条记录的`c4`列存储的是`NULL`值，我们回过头看一下第二条记录的`字段长度偏移列表`如下：

    ```
    A4 A4 1A 17 13 0C 06
    
    ```

    按照列的顺序排放就是：

    ```
    06 0C 13 17 1A A4 A4
    
    ```

    可以看到第二条记录的`c4`列的偏移长度和`c3`列的相同都是`A4`，意味着`c4`列的长度为0，也就意味着存储的是`NULL`值。

  * 如果该存储`NULL`值的字段是`CHAR(M)`数据类型的，则将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。

    如图第二条记录的`c3`列的值是`NULL`，而`c3`列的类型是`CHAR(10)`，占用记录的真实数据部分10字节，所以我们看到在`Redundant`行格式中使用`0x00000000000000000000`来表示`NULL`值。

除了以上的几点之外，`Redundant`行格式和`Compact`行格式还是大致相同的。

#### CHAR(M)列的存储格式

我们知道`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。比方说使用`utf8`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`30`个字节，使用`gbk`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`20`个字节。由此可以看出来，使用`Redundant`行格式的`CHAR(M)`类型的列是不会产生碎片的。

### 行溢出数据

#### VARCHAR(M)最多能存储的数据

我们知道对于`VARCHAR(M)`类型的列最多可以占用`65535`个字节。其中的`M`代表该类型最多存储的字符数量，如果我们使用`ascii`字符集的话，一个字符就代表一个字节，我们看看`VARCHAR(65535)`是否可用：

```
mysql> CREATE TABLE varchar_size_demo(
    ->     c VARCHAR(65535)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
mysql>

```

从报错信息里可以看出，`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

*   真实数据
*   真实数据占用字节的长度
*   `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：

```
mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)

```

如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度可能占用2个字节，不需要`NULL`值标识：

```
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.01 sec)

mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65533) NOT NULL
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)

```

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

```
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=gbk ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT instead

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=utf8 ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT instead

```

从执行结果中可以看出，如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为`NULL`的情况下，`gbk`字符集表示一个字符最多需要`2`个字符，那在该字符集下，`M`的最大取值就是`32766`（也就是：65532/2），也就是说最多能存储`32766`个字符；`utf8`字符集表示一个字符最多需要`3`个字符，那在该字符集下，`M`的最大取值就是`21844`，就是说最多能存储`21844`（也就是：65532/3）个字符。

> 小贴士： 上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！

#### 记录中的数据太多产生的溢出

我们以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

```
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)

```

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB](https://user-gold-cdn.xitu.io/2019/2/22/16910e3fb544aed7?w=1160&h=627&f=png&s=152562)

从图中可以看出来，对于`Compact`和`Reduntant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5ff0a8b3c?w=951&h=213&f=png&s=36684)

最后需要注意的是，不只是 _**VARCHAR(M)**_ 类型的列，其他的 _**TEXT**_、_**BLOB**_ 类型的列在存储数据非常多的时候也会发生`行溢出`。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

* 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`136`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

* 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  *   2个字节用于存储真实数据的长度
  *   1个字节用于存储列是否是NULL值
  *   5个字节大小的头信息
  *   6个字节的`row_id`列
  *   6个字节的`transaction_id`列
  *   7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，那么发生`行溢出`现象时需要满足这个式子：

```
136 + 2×(27 + n) > 16384

```

求解这个式子得出的解是：`n > 8098`。也就是说如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`。不过这个`8098`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生`行溢出`的现象。

### Dynamic和Compressed行格式

下边要介绍另外两个行格式，`Dynamic`和`Compressed`行格式，我现在使用的`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5ff959467?w=791&h=219&f=png&s=30573)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

### CHAR(M)中的M值过大的情况

`CHAR(M)`类型的列可以存储的最大字节长度等于该列使用的字符集表示一个字符需要的最大字节数和`M`的乘积。如果某个列使用的是`CHAR(M)`类型，并且它可以存储的最大字节长度超过`768`字节，那么不论我们使用的是上述4种的哪种行格式，`InnoDB`都会把该列当成变长字段看待。比方说采用`utf8mb4`的`CHAR(255)`类型的列将会被当作变长字段看待，因为`4×255 > 768`。

## 总结

1. 页是`MySQL`中磁盘和内存交互的基本单位，也是`MySQL`是管理存储空间的基本单位。

2. 指定和修改行格式的语法如下：

   ```
   CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
   
   ALTER TABLE 表名 ROW_FORMAT=行格式名称
   
   ```

3. `InnoDB`目前定义了4中行格式

   * COMPACT行格式

     具体组成如图：

     ![image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5702043d7?w=783&h=250&f=png&s=43461)

   * Redundant行格式

     具体组成如图：

     ![image_1ctfppb4c1cng1m8718l91760jde9.png-36.2kB](https://user-gold-cdn.xitu.io/2019/2/21/169104f5ffe017bf?w=618&h=251&f=png&s=37063)

   * Dynamic和Compressed行格式

     这两种行格式类似于`COMPACT行格式`，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

     另外，`Compressed`行格式会采用压缩算法对页面进行压缩。

*   一个页一般是`16KB`，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为`行溢出`。

# 6. 盛放记录的大盒子 —— InnoDB 数据页结构

标签： MySQL 是怎样运行的

* * *

## 不同类型的页简介

前边我们简单提了一下`页`的概念，它是`InnoDB`管理存储空间的基本单位，一个页的大小一般是`16KB`。`InnoDB`为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`Insert Buffer`信息的页，存放`INODE`信息的页，存放`undo`日志信息的页等等等等。当然了，如果我说的这些名词你一个都没有听过，就当我放了个屁吧～ 不过这没有一毛钱关系，我们今儿个也不准备说这些类型的页，我们聚焦的是那些存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（`INDEX`）页，鉴于我们还没有了解过索引是个什么东西，而这些表中的记录就是我们日常口中所称的`数据`，所以目前还是叫这种存放记录的页为`数据页`吧。

## 数据页结构的快速浏览

数据页代表的这块`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![image_1crh8esga1j5l1d6f1idggech95p.png-69kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7d2c1dfc?w=493&h=494&f=png&s=70700)

从图中可以看出，一个`InnoDB`数据页的存储空间大致被划分成了`7`个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。下边我们用表格的方式来大致描述一下这7个部分都存储一些啥内容（快速的瞅一眼就行了，后边会详细唠叨的）：

名称

中文名

占用空间大小

简单描述

`File Header`

文件头部

`38`字节

页的一些通用信息

`Page Header`

页面头部

`56`字节

数据页专有的一些信息

`Infimum + Supremum`

最小记录和最大记录

`26`字节

两个虚拟的行记录

`User Records`

用户记录

不确定

实际存储的行记录内容

`Free Space`

空闲空间

不确定

页中尚未使用的空间

`Page Directory`

页面目录

不确定

页中的某些记录的相对位置

`File Trailer`

文件尾部

`8`字节

校验页是否完整

> 小贴士： 我们接下来并不打算按照页中各个部分的出现顺序来依次介绍它们，因为各个部分中会出现很多大家目前不理解的概念，这会打击各位读文章的信心与兴趣，希望各位能接受这种拍摄手法～

## 记录在页中的存储

在页的7个组成部分中，我们自己存储的记录会按照我们指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![image_1cosvi1in9st476cdqfki1n39m.png-133.8kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7f39b19b?w=1272&h=475&f=png&s=137021)

为了更好的管理在`User Records`中的这些记录，`InnoDB`可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在`User Records`部分么？其实这话还得从记录行格式的`记录头信息`中说起。

### 记录头信息的秘密

为了故事的顺利发展，我们先创建一个表：

```
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)

```

这个新创建的`page_demo`表有3个列，其中`c1`和`c2`列是用来存储整数的，`c3`列是用来存储字符串的。需要注意的是，我们把 _**c1**_ 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 _**row\_id**_ 隐藏列了。而且我们为这个表指定了`ascii`字符集以及`Compact`的行格式。所以这个表中记录的行格式示意图就是这样的：

![image_1c9o2eib2vl11qnf1dfl1d2lco313.png-76.4kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7fb96a2b?w=1121&h=474&f=png&s=78271)

从图中可以看到，我们特意把`记录头信息`的5个字节的数据给标出来了，说明它很重要，我们再次先把这些`记录头信息`中各个属性的大体意思浏览一下（我们目前使用`Compact`行格式进行演示）：

名称

大小（单位：bit）

描述

`预留位1`

`1`

没有使用

`预留位2`

`1`

没有使用

`delete_mask`

`1`

标记该记录是否被删除

`min_rec_mask`

`1`

B+树的每层非叶子节点中的最小记录都会添加该标记

`n_owned`

`4`

表示当前记录拥有的记录数

`heap_no`

`13`

表示当前记录在记录堆的位置信息

`record_type`

`3`

表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录

`next_record`

`16`

表示下一条记录的相对位置

由于我们现在主要在唠叨`记录头信息`的作用，所以为了大家理解上的方便，我们只在`page_demo`表的行格式演示图中画出有关的头信息属性以及`c1`、`c2`、`c3`列的信息（其他信息没画不代表它们不存在啊，只是为了理解上的方便在图中省略了～），简化后的行格式示意图就是这样：

![image_1c9o52lt41v5c7vk1vm91fsm174b2d.png-49.5kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7fc922e1?w=759&h=347&f=png&s=50721)

下边我们试着向`page_demo`表中插入几条记录：

```
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

```

为了方便大家分析这些记录在`页`的`User Records`部分中是怎么表示的，我把记录中头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：

![image_1c9qs0j281knc16hc1hqsgj01v0o2c.png-82.8kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7fa53c71?w=948&h=333&f=png&s=84803)

看这个图的时候需要注意一下，各条记录在`User Records`中存储的时候并没有空隙，这里只是为了大家观看方便才把每条记录单独画在一行中。我们对照着这个图来看看记录头信息中的各个属性是啥意思：

* `delete_mask`

  这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。

  啥？被删除的记录还在`页`中么？是的，摆在台面上的和背地里做的可能大相径庭，你以为它删除了，可它还在真实的磁盘上\[摊手\]（忽然想起冠希～）。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

  > 小贴士： 将这个delete\_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细唠叨删除操作的详细过程，稍安勿躁。

* `min_rec_mask`

  B+树的每层非叶子节点中的最小记录都会添加该标记，什么是个`B+`树？什么是个非叶子节点？好吧，等会再聊这个问题。反正我们自己插入的四条记录的`min_rec_mask`值都是`0`，意味着它们都不是`B+`树的非叶子节点中的最小记录。

* `n_owned`

  这个暂时保密，稍后它是主角～

* `heap_no`

  这个属性表示当前记录在本`页`中的位置，从图中可以看出来，我们插入的4条记录在本`页`中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见`heap_no`值为`0`和`1`的记录呢？

  这其实是设计`InnoDB`的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`，等一下哈~，记录可以比大小么？

  是的，记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较`主键`的大小。比方说我们插入的4行记录的主键值分别是：`1`、`2`、`3`、`4`，这也就意味着这4条记录的大小从小到大依次递增。

  > 小贴士： 请注意我强调了对于\`一条完整的记录\`来说，比较记录的大小就相当于比的是主键的大小。后边我们还会介绍只存储一条记录的部分列的情况，敬请期待～

  但是不管我们向`页`中插入了多少自己的记录，设计`InnoDB`的大叔们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的`记录头信息`和8字节大小的一个固定的部分组成的，如图所示

  ![image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faaae699d06?w=576&h=395&f=png&s=51648)

  由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分，如图所示：

  ![image_1c9qs1mn2t3j1nt344116nk15uf2p.png-119.7kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faa7fb8234e?w=1020&h=458&f=png&s=122559)

  从图中我们可以看出来，最小记录和最大记录的`heap_no`值分别是`0`和`1`，也就是说它们的位置最靠前。

* `record_type`

  这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的`record_type`值都是`0`，而最小记录和最大记录的`record_type`值分别为`2`和`3`。

  至于`record_type`为`1`的情况，我们之后在说索引的时候会重点强调的。

* `next_record`

  这玩意儿非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个`链表`，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，`下一条记录`指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 _**Infimum记录（也就是最小记录）**_ 的下一条记录就本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 _**Supremum记录（也就是最大记录）**_ ，为了更形象的表示一下这个`next_record`起到的作用，我们用箭头来替代一下`next_record`中的地址偏移量：

  ![image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faaae5618fb?w=1044&h=549&f=png&s=123443)

  从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录`的`next_record`的值为`0`，这也就是说最大记录是没有`下一条记录`了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：

  ```
  mysql> DELETE FROM page_demo WHERE c1 = 2;
  Query OK, 1 row affected (0.02 sec)
  
  ```

  删掉第2条记录后的示意图就是：

  ![image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faaae709be3?w=1032&h=528&f=png&s=122514)

  从图中可以看出来，删除第2条记录前后主要发生了这些变化：

  *   第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
  *   第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
  *   第1条记录的`next_record`指向了第3条记录。
  *   还有一点你可能忽略了，就是`最大记录`的`n_owned`值从`5`变成了`4`，关于这一点的变化我们稍后会详细说明的。

  所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

  > 小贴士： 你会不会觉得next\_record这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？ 因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。而且next\_record指针始终是从该位置开始向左读取的第一个属性，这意味着可以非常有效地读取页面中的所有记录，而无需解析变长字段长度列表、NULL值列表之类的可变长度部分。另外，由于从next\_record指针处向左读是记录的额外信息部分，所以我们之前说变长字段长度列表、NULL值列表中的信息都是逆序存放的意思大家也就理解了。

再来看一个有意思的事情，因为主键值为`2`的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？

```
mysql> INSERT INTO page_demo VALUES(2, 200, 'bbbb');
Query OK, 1 row affected (0.00 sec)

```

我们看一下记录的存储情况：

![image_1cot2j9n94a511jd15clrrfp6p1t.png-137.8kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faaae8b46cd?w=1120&h=557&f=png&s=141111)

从图中可以看到，`InnoDB`并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。

> 小贴士： 当数据页中存在多条被删除掉的记录时，这些记录的next\_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

## Page Directory（页目录）

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：

```
SELECT * FROM page_demo WHERE c1 = 3;

```

最笨的办法：从`Infimum`记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到\[摊手\]），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。

这个方法在页中存储的记录数量比较少的情况用起来也没啥问题，比方说现在我们的表里只有`4`条自己插入的记录，所以最多找`4`次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是有损耗的，所以我们说这种遍历查找这是一个`笨`办法。但是设计`InnoDB`的大叔们是什么人，他们能用这么笨的办法么，当然是要设计一种更6的查找方式喽，他们从书的目录中找到了灵感。

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计`InnoDB`的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

1.  将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

2.  每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

3.  将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。

比方说现在的`page_demo`表中正常的记录共有6条，`InnoDB`会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：

![image_1couapvdmb5mvm1i0l5m0vcb2a.png-128.2kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faaaea593a4?w=1011&h=540&f=png&s=131292)

从这个图中我们需要注意这么几点：

*   现在`页目录`部分中有两个槽，也就意味着我们的记录被分成了两个组，`槽0`中的值是`112`，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；`槽1`中的值是`99`，代表最小记录的地址偏移量。

*   注意最小和最大记录的头信息中的`n_owned`属性

    *   最小记录的`n_owned`值为`1`，这就代表着以最小记录结尾的这个分组中只有`1`条记录，也就是最小记录本身。
    *   最大记录的`n_owned`值为`5`，这就代表着以最大记录结尾的这个分组中只有`5`条记录，包括最大记录本身还有我们自己插入的`4`条记录。

`99`和`112`这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：

![image_1couarh4no6j1a8q9htilr13qc2n.png-105.1kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faab125e162?w=1032&h=537&f=png&s=107616)

哎呀，咋看上去怪怪的，这么乱的图对于我这个强迫症真是不能忍，那我们就暂时不管各条记录在存储设备上的排列方式了，单纯从逻辑上看一下这些记录和页目录的关系：

![image_1couate3jr19gc18gl1cva1fcg34.png-100.8kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faacfbd4080?w=994&h=550&f=png&s=103256)

这样看就顺眼多了嘛！为什么最小记录的`n_owned`值为1，而最大记录的`n_owned`值为`5`呢，这里头有什么猫腻么？

是的，设计`InnoDB`的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 _**1**_ 条记录，最大记录所在的分组拥有的记录条数只能在 _**1~8**_ 条之间，剩下的分组中记录的条数范围只能在是 _**4~8**_ 条之间。所以分组是按照下边的步骤进行的：

*   初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。

*   之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。

*   在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

由于现在`page_demo`表中的记录太少，无法演示添加了`页目录`之后加快查找速度的过程，所以再往`page_demo`表中添加一些记录：

```
mysql> INSERT INTO page_demo VALUES(5, 500, 'eeee'), (6, 600, 'ffff'), (7, 700, 'gggg'), (8, 800, 'hhhh'), (9, 900, 'iiii'), (10, 1000, 'jjjj'), (11, 1100, 'kkkk'), (12, 1200, 'llll'), (13, 1300, 'mmmm'), (14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');
Query OK, 12 rows affected (0.00 sec)
Records: 12  Duplicates: 0  Warnings: 0

```

哈，我们一口气又往表中添加了12条记录，现在就一共有16条正常的记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：

![image_1coub0tq01b8scui9ia1fge124b3h.png-185.7kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faad54ff9e6?w=1034&h=637&f=png&s=190111)

因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的`n_owned`和`next_record`属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个`页目录`中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的`二分法`来进行快速查找。4个槽的编号分别是：`0`、`1`、`2`、`3`、`4`，所以初始情况下最低的槽就是`low=0`，最高的槽就是`high=4`。比方说我们想找主键值为`5`的记录，过程是这样的：

1.  计算中间槽的位置：`(0+4)/2=2`，所以查看`槽2`对应记录的主键值为`8`，又因为`8 > 5`，所以设置`high=2`，`low`保持不变。

2.  重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`。所以设置`low=1`，`high`保持不变。

3.  因为`high - low`的值为1，所以确定主键值为`5`的记录在`槽2`对应的组中，接下来就是通过遍历`槽2`对应的组的链表来进行查找了。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1.  通过二分法确定该记录所在的槽。

2.  通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

> 小贴士： 如果你不知道二分法是个什么东西，找个基础算法书看看吧。什么？算法书写的看不懂？等我～

## Page Header（页面头部）

设计`InnoDB`的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫`Page Header`的部分，它是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

名称

占用空间大小

描述

`PAGE_N_DIR_SLOTS`

`2`字节

在页目录中的槽数量

`PAGE_HEAP_TOP`

`2`字节

还未使用的空间最小地址，也就是说从该地址之后就是`Free Space`

`PAGE_N_HEAP`

`2`字节

本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）

`PAGE_FREE`

`2`字节

第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用）

`PAGE_GARBAGE`

`2`字节

已删除记录占用的字节数

`PAGE_LAST_INSERT`

`2`字节

最后插入记录的位置

`PAGE_DIRECTION`

`2`字节

记录插入的方向

`PAGE_N_DIRECTION`

`2`字节

一个方向连续插入的记录数量

`PAGE_N_RECS`

`2`字节

该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）

`PAGE_MAX_TRX_ID`

`8`字节

修改当前页的最大事务ID，该值仅在二级索引中定义

`PAGE_LEVEL`

`2`字节

当前页在B+树中所处的层级

`PAGE_INDEX_ID`

`8`字节

索引ID，表示当前页属于哪个索引

`PAGE_BTR_SEG_LEAF`

`10`字节

B+树叶子段的头部信息，仅在B+树的Root页定义

`PAGE_BTR_SEG_TOP`

`10`字节

B+树非叶子段的头部信息，仅在B+树的Root页定义

如果大家认真看过前边的文章，从`PAGE_N_DIR_SLOTS`到`PAGE_LAST_INSERT`以及`PAGE_N_RECS`的意思大家一定是清楚的，如果不清楚，对不起，你应该回头再看一遍前边的文章。剩下的状态信息看不明白不要着急，饭要一口一口吃，东西要一点一点学（一定要稍安勿躁哦，不要被这些名词吓到）。在这里我们先唠叨一下`PAGE_DIRECTION`和`PAGE_N_DIRECTION`的意思：

* `PAGE_DIRECTION`

  假如新插入的一条记录的主键值比上一条记录的主键值比上一条记录大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是`PAGE_DIRECTION`。

* `PAGE_N_DIRECTION`

  假设连续几次插入新记录的方向都是一致的，`InnoDB`会把沿着同一个方向插入记录的条数记下来，这个条数就用`PAGE_N_DIRECTION`这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

至于我们没提到的那写属性，我没说是因为现在不需要大家知道。不要着急，当我们学完了后边的内容，你再回头看，一切都是那么清晰。

> 小贴士： 说到这个有些东西后边我们学过后回头看就很清晰的事儿不禁让我想到了乔布斯在斯坦福大学的演讲，摆一下原文： “You can't connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.” 上边这段话纯属心血来潮写的，大意是坚持做自己喜欢的事儿，你在做的时候可能并不能搞清楚这些事儿对自己之后的人生有啥影响，但当你一路走来回头看时，一切都是那么清晰，就像是命中注定的一样。上述内容跟MySQL毫无干系，请忽略～

## File Header（文件头部）

上边唠叨的`Page Header`是专门针对`数据页`记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的`File Header`针对各种类型的页都通用，也就是说不同类型的页都会以`File Header`作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的`38`个字节，是由下边这些内容组成的：

名称

占用空间大小

描述

`FIL_PAGE_SPACE_OR_CHKSUM`

`4`字节

页的校验和（checksum值）

`FIL_PAGE_OFFSET`

`4`字节

页号

`FIL_PAGE_PREV`

`4`字节

上一个页的页号

`FIL_PAGE_NEXT`

`4`字节

下一个页的页号

`FIL_PAGE_LSN`

`8`字节

页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）

`FIL_PAGE_TYPE`

`2`字节

该页的类型

`FIL_PAGE_FILE_FLUSH_LSN`

`8`字节

仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值

`FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID`

`4`字节

页属于哪个表空间

对照着这个表格，我们看几个目前比较重要的部分：

* `FIL_PAGE_SPACE_OR_CHKSUM`

  这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为`校验和`。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

* `FIL_PAGE_OFFSET`

  每一个`页`都有一个单独的页号，就跟你的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个`页`。

* `FIL_PAGE_TYPE`

  这个代表当前`页`的类型，我们前边说过，`InnoDB`为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的`数据页`，其实还有很多别的类型的页，具体如下表：

  类型名称

  十六进制

  描述

  `FIL_PAGE_TYPE_ALLOCATED`

  0x0000

  最新分配，还没使用

  `FIL_PAGE_UNDO_LOG`

  0x0002

  Undo日志页

  `FIL_PAGE_INODE`

  0x0003

  段信息节点

  `FIL_PAGE_IBUF_FREE_LIST`

  0x0004

  Insert Buffer空闲列表

  `FIL_PAGE_IBUF_BITMAP`

  0x0005

  Insert Buffer位图

  `FIL_PAGE_TYPE_SYS`

  0x0006

  系统页

  `FIL_PAGE_TYPE_TRX_SYS`

  0x0007

  事务系统数据

  `FIL_PAGE_TYPE_FSP_HDR`

  0x0008

  表空间头部信息

  `FIL_PAGE_TYPE_XDES`

  0x0009

  扩展描述页

  `FIL_PAGE_TYPE_BLOB`

  0x000A

  BLOB页

  `FIL_PAGE_INDEX`

  0x45BF

  索引页，也就是我们所说的`数据页`

  我们存放记录的数据页的类型其实是`FIL_PAGE_INDEX`，也就是所谓的`索引页`。至于啥是个索引，且听下回分解～

* `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

  我们前边强调过，`InnoDB`都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），`InnoDB`可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的`数据页`（也就是类型为`FIL_PAGE_INDEX`的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：

  ![image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB](https://user-gold-cdn.xitu.io/2019/2/22/16910faad0e37047?w=898&h=365&f=png&s=93102)

关于`File Header`的其他属性我们暂时用不到，等用到的时候再提哈～

## File Trailer

我们知道`InnoDB`存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计`InnoDB`的大叔们在每个页的尾部都加了一个`File Trailer`部分，这个部分由`8`个字节组成，可以分成2个小部分：

* 前4个字节代表页的校验和

  这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trialer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

* 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

  这个部分也是为了校验页的完整性的，只不过我们目前还没说`LSN`是个什么意思，所以大家可以先不用管这个属性。

这个`File Trailer`与`FILE Header`类似，都是所有类型的页通用的。

## 总结

1.  InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做`数据页`。

2.  一个数据页可以被大致划分为7个部分，分别是

    *   `File Header`，表示页的一些通用信息，占固定的38字节。
    *   `Page Header`，表示数据页专有的一些信息，占固定的56个字节。
    *   `Infimum + Supremum`，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的`26`个字节。
    *   `User Records`：真实存储我们插入的记录的部分，大小不固定。
    *   `Free Space`：页中尚未使用的部分，大小不确定。
    *   `Page Directory`：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
    *   `File Trailer`：用于检验页是否完整的部分，占用固定的8个字节。
3.  每个记录的头信息中都有一个`next_record`属性，从而使页中的所有记录串联成一个`单链表`。

4.  `InnoDB`会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：

    *   通过二分法确定该记录所在的槽。

    *   通过记录的next\_record属性遍历该槽所在的组中的各个记录。

5.  每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。

6.  为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的`LSN`值，如果首部和尾部的校验和和`LSN`值校验不成功的话，就说明同步过程出现了问题。

# 7. 快速查询的秘籍 —— B+ 树索引

# 8. 好东西也得先学会怎么用 —— B+ 树索引的使用

# 9. 数据的家 —— MySQL 的数据目录

# 10. 存放页面的大池子 —— InnoDB 的表空间

# 11. 条条大路通罗马 —— 单表访问方法

# 12. 两个表的亲密接触 —— 连接的原理

# 13. 谁最便宜就选谁 —— MySQL 基于成本的优化

# 14. 兵马未动，粮草先行 —— InnoDB 统计数据是如何收集的

# 15. 不好看就要多整容 —— MySQL 基于规则的优化（内含关于子查询优化二三事儿）

# 16. 查询优化的百科全书 —— Explain 详解（上）

# 17. 查询优化的百科全书 —— Explain 详解（下）

# 18. 神兵利器 —— optimizer trace 的神器功效

# 19. 调节磁盘和CPU的矛盾 —— InnoDB 的 Buffer Pool

# 20. 从猫爷被杀说起 —— 事务简介

# 21. 说过的话就一定要办到 —— redo 日志（上）

# 22. 说过的话就一定要办到 —— redo 日志（下）

# 23. 后悔了怎么办 —— undo 日志

# 24. 工作面试老大难 —— 锁

# 25. 写作本书时用到的一些重要的参考资料